#pragma kernel MarchingCubes
#include "Lookup.compute"

struct Triangle 
{
    float3 a, b, c;
};

float isoLevel;
float3 chunkSize;
RWStructuredBuffer<float> densities;
AppendStructuredBuffer<Triangle> triangleRW; 


float3 vertexInterp(float3 vPos1, float3 vPos2, float density1, float density2)
{
	return lerp(vPos1, vPos2, (isoLevel - density1) / (density2 - density1));
}


[numthreads(8, 8, 8)]
void MarchingCubes(uint3 threadId : SV_DispatchThreadID) 
{
    if (threadId.x >= chunkSize.x - 1  || threadId.y >= chunkSize.y - 1|| threadId.z >= chunkSize.z - 1) {
        return;
    }

    float cubeDensity[8] = {
        densities[threadId + cubeVertOffsets[0]],
        densities[threadId + cubeVertOffsets[1]],
        densities[threadId + cubeVertOffsets[2]],
        densities[threadId + cubeVertOffsets[3]],
        densities[threadId + cubeVertOffsets[4]],
        densities[threadId + cubeVertOffsets[5]],
        densities[threadId + cubeVertOffsets[6]],
        densities[threadId + cubeVertOffsets[7]]
    };


    int cubeIndex = 0;
	if (cubeDensity[0] < isoLevel) cubeIndex |= 1;
	if (cubeDensity[1] < isoLevel) cubeIndex |= 2;
	if (cubeDensity[2] < isoLevel) cubeIndex |= 4;
	if (cubeDensity[3] < isoLevel) cubeIndex |= 8;
	if (cubeDensity[4] < isoLevel) cubeIndex |= 16;
	if (cubeDensity[5] < isoLevel) cubeIndex |= 32;
	if (cubeDensity[6] < isoLevel) cubeIndex |= 64;
	if (cubeDensity[7] < isoLevel) cubeIndex |= 128;

    for (int i = 0; triTable[cubeIndex][i] != -1; i +=3) 
    {

        int a0 = cornerIndexAFromEdge[triTable[cubeIndex][i]];
        int b0 = cornerIndexBFromEdge[triTable[cubeIndex][i]];

        int a1 = cornerIndexAFromEdge[triTable[cubeIndex][i + 1]];
        int b1 = cornerIndexBFromEdge[triTable[cubeIndex][i + 1]];

        int a2 = cornerIndexAFromEdge[triTable[cubeIndex][i + 2]];
        int b2 = cornerIndexBFromEdge[triTable[cubeIndex][i + 2]];

        Triangle tri;
        tri.a = vertexInterp((threadId + cubeVertOffsets[a0]), (threadId + cubeVertOffsets[b0]), cubeDensity[a0], cubeDensity[b0]);
        tri.b = vertexInterp((threadId + cubeVertOffsets[a0]), (threadId + cubeVertOffsets[b0]), cubeDensity[a0], cubeDensity[b0]);
        tri.c = vertexInterp((threadId + cubeVertOffsets[a0]), (threadId + cubeVertOffsets[b0]), cubeDensity[a0], cubeDensity[b0]); 

        triangleRW.Append(tri); 
    }
}


